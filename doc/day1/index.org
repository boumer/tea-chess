* Day 1

** First things first
Before you can start, make sure you have the following installed:

- [[https://nodejs.org/][Node.js]] and optionally [[https://yarnpkg.com/][Yarn]]. Bucklescript piggybacks on the [[https://www.npmjs.com/][NPM
  package database]], and I'm afraid I don't know how to do Bucklescript
  development without it. I prefer Yarn as an interface to NPM and use
  Yarn commands throughout this tutorial, but if you are already using
  NPM, it will work just as fine.

- [[https://opam.ocaml.org/doc/Install.html][OPAM]], the OCaml package manager.  You can use Bucklescript without
  OPAM, but I strongly recommend you to use the excellent [[https://github.com/ocaml/merlin][Merlin]] tool
  for an [[https://opam.ocaml.org/blog/turn-your-editor-into-an-ocaml-ide/][IDE-like experience in your editor]].  If you want to explore
  server-side OCaml as well, OPAM will allow you to switch between
  different versions of OCaml packages for server-side and client-side
  development seamlessly.

Let's setup a project directory structure. Arguably the easiest way is
to just clone the [[https://github.com/tcoopman/bucklescript-tea-starter-kit][Bucklescript-TEA starter kit]], copy the relevant
files into a fresh repository, or just follow along with [[https://www.github.com/quernd/tea-chess][my
repository]]. (I actually used [[http://www.fossil-scm.org/][Fossil]] for local version control, and I
encourage you to use any version control system that you are
comfortable with). If you follow along my code, start from the tag
~initial~ by typing ~git checkout initial~.

Take a look at the files in the starter kit. You will notice that
~package.json~ lists a few dependencies for local development and
defines build and watch scripts. Furthermore, ~bsconfig.json~ contains
instructions for the Bucklescript compiler. Your OCaml source code
will go in the ~src~ directory, and the compiled Javascript will be
put into ~release~ by the build script. Why don't you edit
~package.json~ and ~bsconfig.json~ for a better package name (e.g.
~tea-chess~)?

Now run ~yarn install~ (or ~npm install~) to install the dependencies.
The main Bucklescript package ~bs-platform~ is pretty hefty (it brings
its own OCaml compiler) and takes a while to setup, so I installed it
globally with ~yarn global add install bs-platform --offline~. This
way, I can just link it with ~yarn link~ (in its global location) and
then ~yarn link bs-platform~ in your project directory whenever I
start a Bucklescript project to save time and bandwidth.

You are now ready to run ~yarn run watch~. You should see the build
script work to compile OCaml code into Javascript and eventually
display something like the following:

#+BEGIN_SRC
rollup v0.52.3
bundles ./src/Main.bs.js → release/main.js...

   ┌─────────────────────────────────────────────────┐
   │                                                 │
   │   Serving!                                      │
   │                                                 │
   │   - Local:            http://localhost:5000     │
   │   - On Your Network:  http://192.168.1.5:5000   │
   │                                                 │
   │   Copied local address to clipboard!            │
   │                                                 │
   └─────────────────────────────────────────────────┘

LiveReload enabled
created release/main.js in 1.3s

[2017-12-23 21:39:55] waiting for changes...
#+END_SRC

Congratulations! Visit the page in your web browser and play with the
counters example a little. Whenever you make changes to your code, as
soon as you save the file, the build script will notice and recompile
your code, and the new javascript code will even be "hot-reloaded" in
your browser! Whenever something goes wrong, you will find a helpful
error message displayed.

If you are extraordinarily attentive, you may have noticed that there
is a new file ~.merlin~ in the root level of your project. This file
will tell the extremely useful [[https://github.com/ocaml/merlin][Merlin]] tool where to find your source
code and intermediate files so it can help you with type annotations.
I strongly encourage you to use an editor that integrates Merlin. I
use [[https://github.com/ocaml/merlin/wiki/emacs-from-scratch][Emacs]], but you can also use other editors with Merlin, such as
[[https://github.com/ocaml/merlin/wiki/vim-from-scratch][Vim]], [[https://github.com/ocaml/merlin/wiki/atom-from-scratch][Atom]], or [[https://github.com/hackwaly/vscode-ocaml][VS Code]]. If you use OPAM to maintain different versions
of the OCaml compiler, make sure that Merlin is setup to work with the
Bucklescript version.

** The Elm architecture

Open ~src/Main.ml~ and take a look at the code. Now, if you are
familiar with the "Elm architecture", made popular by the Elm language
of Evan Czaplicki, you will recognize the typical /msg/, /model/,
/update/, and /view/ definitions. Essentially, Bucklescript-TEA
provides an API similar, if not almost compatible, to that of Elm's. I'm not going to provide a thorough
discussion in case you haven't worked with the Elm architecture before.  There are lots of resources online that do a better job I
ever could do.  For instance, check out the [[https://guide.elm-lang.org/architecture/][official tutorial]]. However, the Elm architecture is pretty simple to
grasp if all you remember is this:

1. Your program state is represented by a /model/.
2. Whenever stuff happens (user clicks a button, AJAX data comes in,
   etc.), the /update/ function receives a /message/ and the current
   /model/ and returns a new /model/.
3. The /view/ function computes a
   virtual DOM tree from the model (which is rendered to the
   screen) and a recipe for any side effects that you would like to
   execute (called a /command/).
4. Side effects are managed behind the scenes to ensure that your
   functions stay pure; when a side effect is actually executed, it
   gets boxed into a /message/.  In addition to commands, your program
   can listen to /subscriptions/ to receive messages
   on events such as mouse and keyboard events, websockets, and time.

If you installed Merlin, you can use it to examine the types of the
functions involved in the Elm Architecture. For instance, if you're
using Emacs, press @@html:<kbd>C-c C-t</kbd>@@, and Merlin will tell
you the type of the function name at the point (cursor):

- ~init~ has type ~unit -> int~, hence our model is of type ~int~.
- ~update~ is of type ~int -> msg -> int~, meaning it takes a model
  (of type ~int~) and a message from the variant type ~msg~, and
  returns a new model of type ~int~
- ~view~ has type ~int -> msg Vdom.t~.  This means it takes a model
  and returns a virtual DOM element that can trigger messages of type
  ~msg~.  We say that ~msg Vdom.t~ is a /parameterized type/.
- ~view_button~ is of type ~string -> 'a -> 'a Vdom.t~.  This means it
  takes a string and another argument of an as-of-yet unknown type
  (~'a~ is a /type variable/) and returns a ~Vdom.t~ that is
  parameterized by ~'a~.  This may sound confusing, but it really just
  means that ~view_button~ is a very generic function.  It will work
  with any message type, not just with the type ~msg~ we defined
  earlier!

Of course, OCaml will be extremely strict to enforce correct types, so
whenever you make a type-related mistake, it will refuse to compile
your code. This may sound painful, but I find that not only does it
catch zillions of bugs before they hit the user, it also really helps
with refactoring. Also, OCaml will infer almost every type
automatically, leaving you without the need to explicitly annotate
types.

** Starting from (almost) scratch

To see if hot reloading works, try changing the line 
#+BEGIN_SRC ocaml 
let init () = 4
#+END_SRC 
to any other number than 4.  This sets the initial model, which in
this case is just an integer.  The counter should automatically update
in your browser.  Play with the example or examine the code if you
want to learn about the basics of the Elm architecture and Bucklescript-TEA.

Now, let's get rid of the counter example because that doesn't have
anything to do with chess, and start adding our own
code.  I stripped down the /model-update-view/ loop in ~src/Main.ml~
and added the basics of a chess-related model:

#+BEGIN_SRC ocaml
open Tea
open Tea.Html

type color =
  | Black
  | White

type model =
  { orientation : color
  }

type msg =
  | Flip
[@@bs.deriving {accessors}]

let init () =
  { orientation = White
  }, Cmd.none

let update model = function
  | Flip ->
    let orientation' = match model.orientation with
      | Black -> White
      | White -> Black in
    { orientation = orientation'
    }, Cmd.none

let view _model =
  noNode

let subscriptions _model =
  Sub.none

let main =
  App.standardProgram
    { init
    ; update
    ; view
    ; subscriptions
    }
#+END_SRC

Our model is an OCaml record with one field
~orientation~, taking its value from a variant type ~color~ to
represent from which side we will see the chessboard.  We
define one message called ~Flip~, that when received, will flip the
orientation of the chessboard around.

Notice how we're now using ~standardProgram~ instead of beginner
program.  Hooray, you're not a beginner anymore!  This means we will
be able to listen for subscriptions such as mouse and keyboard events.  You will learn about them
when we implement drag and drop to make moves on the chessboard.
Right now, we choose ~Sub.none~ to express that we are not interested
in any subscriptions yet, regardless of the model. Similarly, we don't
want to issue any commands, so we return ~Cmd.none~ along with the
model everytime.

Also notice that
#+BEGIN_SRC ocaml
let update model = function
  | Flip ->
#+END_SRC
is a shorthand way of writing
#+BEGIN_SRC ocaml
let update model msg =
  match msg with
  | Flip ->
#+END_SRC
because ~function~ has built-in pattern-matching.

** Your first view function

We still need to write a meaningful ~view~ function, of course.  Right
now it only returns ~noNode~, which is a placeholder for when you
don't want to display anything in the DOM.  Without further ado, here
we go:

#+BEGIN_SRC ocaml
let view model =
  let files, ranks =
    match model.orientation with
    | White -> [0; 1; 2; 3; 4; 5; 6; 7], [7; 6; 5; 4; 3; 2; 1; 0]
    | Black -> [7; 6; 5; 4; 3; 2; 1; 0], [0; 1; 2; 3; 4; 5; 6; 7]
  and char_of_file file = "abcdefgh".[file]
  and char_of_rank rank = "12345678".[rank] in

  let rank_view rank =
    let square_view rank file =
      td []
        [ Printf.sprintf "%c%c" (char_of_file file) (char_of_rank rank) 
          |> text
        ] in
    List.map (square_view rank) files
    |> tr [] in

  div []
    [ List.map rank_view ranks
      |> table []
    ; button [onClick Flip] [text "flip board"]
    ]
#+END_SRC 

This might be a little hard to digest, so here's what happens:

A chessboard has 8 rows called "ranks", and 8 columns called "files".
Ranks are numbered, while files are referred to by a letter, so we
define helper functions ~char_of_file~ and ~char_of_rank~.  White's
pieces start the game on ranks 1 and 2, while Black's pieces start on
ranks 7 and 8.  Customarily, a chessboard from White's perspective
will have ranks 1 and 2 at the bottom.  That's why we have to iterate
through files and ranks a little differently according to the board
orientation.

The ~view~ function returns a ~<div>~ containing a
table representing the chessboard as well as a button that will
trigger the ~Flip~ message.  The table is constructed by iterating
over the ranks, and every row is constructed by iterating over the
files.  Each table cell contains a string representation of the square
coordinates.  The functions ~div~, ~table~, ~tr~ and ~td~ are defined
in ~Tea.Html~.  Each of them takes two arguments: a list of attributes
and a list of children.  Since we use these and other HTML-generating functions
a lot, it makes sense to put ~open Tea.Html~ into our code.

Click the button and see if the ~Flip~ message was wired correctly.
You should see the coordinates changing according to the board's orientation.

Now let's make this board look a little more like an actual chessboard
by adding a checkerboard pattern.  We'll assign some CSS style to the
individual squares.  Change the first argument to ~td~ as follows, and
you should see black and white squares.  

#+BEGIN_SRC ocaml
      td
        [ styles
            (if (file + rank) mod 2 = 0
             then [ "background-color", "black"
                  ; "color", "white"
                  ]
             else [])
        ]
#+END_SRC

However, we can be a little more sophisticated and use CSS to color
the squares for us.  I borrowed some CSS from [[https://github.com/oakmac/chessboardjs][a popular Javascript
chessboard library]] and tweaked it a little[fn:1].  Put the following in a
file called ~release/css/main.css~ and make sure the stylesheet is
also referenced in the header of ~release/index.html~:

#+BEGIN_SRC css
cb-board {
    display: inline-block;
    border: 1px solid #404040;
    box-sizing: content-box;
    width: 480px;
    height: 480px;
}

cb-row:after {
    display: block;
    clear: both;
}
cb-row:nth-child(even) cb-square:nth-child(even) {
    background-color: #f0d9b5;
    color: #b58863;
}
cb-row:nth-child(even) cb-square:nth-child(odd) {
    background-color: #b58863;
    color: #f0d9b5;
}
cb-row:nth-child(odd) cb-square:nth-child(even) {
    background-color: #b58863;
    color: #f0d9b5;
}
cb-row:nth-child(odd) cb-square:nth-child(odd) {
    background-color: #f0d9b5;
    color: #b58863;
}

cb-square {
    float: left;
    position: relative;
    display: inline-block;
    user-select: none;
    width: 60px;
    height: 60px;
}
#+END_SRC

Instead of a table, we will use custom HTML tags for our board, and
the checkerboard pattern is achieved by using the odd and even child
selectors.  Now the ~view~ function is a lot simpler:

#+BEGIN_SRC ocaml
let view model =
  let files, ranks =
    match model.orientation with
    | White -> [0; 1; 2; 3; 4; 5; 6; 7], [7; 6; 5; 4; 3; 2; 1; 0]
    | Black -> [7; 6; 5; 4; 3; 2; 1; 0], [0; 1; 2; 3; 4; 5; 6; 7]
  and char_of_file file = "abcdefgh".[file]
  and char_of_rank rank = "12345678".[rank] in

  let rank_view rank =
    let square_view rank file =
      node "cb-square"
        [ style "text-align" "center" ]
        [ Printf.sprintf "%c%c" (char_of_file file) (char_of_rank rank) 
          |> text
        ] in
    List.map (square_view rank) files
    |> node "cb-row" [] in

  div []
    [ List.map rank_view ranks
      |> node "cb-board" []
    ; p [] [button [onClick Flip] [text "flip board"]]
    ]
#+END_SRC

We use ~node~ (defined in ~Tea.Html~) to define our custom tags.  You
should now see a nice-looking chessboard.  Just a small problem: still
no pieces!  Tomorrow, we will add pieces and teach our program to make
random moves on the board.


[fn:1] There is also [[https://github.com/ornicar/chessground][Chessground]], used by the famous open-source,
donation-based [[https://en.lichess.org/][Lichess]] online chess server, for inspiration on how to
code a chessboard.
